card_bot/
â”œâ”€â”€ bot.py
â”œâ”€â”€ database.py
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ user.py
â”‚   â”œâ”€â”€ admin.py
â”‚   â””â”€â”€ owner.py
â”œâ”€â”€ models/
â”‚   â””â”€â”€ models.py
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ rarity.py
â””â”€â”€ data/
    â””â”€â”€ cards.json

pip install pyrogram tgcrypto

from pyrogram import Client
from handlers import user, admin, owner

app = Client("card_bot", api_id=123456, api_hash="your_api_hash", bot_token="your_bot_token")

# Register handlers
user.register(app)
admin.register(app)
owner.register(app)

if __name__ == "__main__":
    print("Bot is running...")
    app.run()

import json
from pathlib import Path

DB_PATH = Path("data/cards.json")

def load_cards():
    if DB_PATH.exists():
        with open(DB_PATH, "r") as f:
            return json.load(f)
    return {"cards": [], "users": {}, "banned": []}

def save_cards(data):
    with open(DB_PATH, "w") as f:
        json.dump(data, f, indent=4)

import random

RARITY_CHANCES = {
    "common": 40,
    "uncommon": 25,
    "rare": 15,
    "legendary": 8,
    "history": 5,
    "divine": 4,
    "exotic": 2,
    "edit": 1
}

RARITY_EMOJIS = {
    "common": "âšªï¸",
    "uncommon": "ğŸŸ£",
    "rare": "ğŸŸ ",
    "legendary": "ğŸŸ¡",
    "history": "ğŸ”±",
    "divine": "ğŸŒŸ",
    "exotic": "ğŸ’",
    "edit": "âœ¨"
}

def get_random_rarity():
    pool = []
    for rarity, chance in RARITY_CHANCES.items():
        pool.extend([rarity] * chance)
    return random.choice(pool)

from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from database import load_cards, save_cards
from utils.rarity import RARITY_EMOJIS
import re

def register(app: Client):
    @app.on_message(filters.command("get") & filters.group)
    def get_card(client: Client, message: Message):
        data = load_cards()
        user_id = str(message.from_user.id)
        if user_id in data.get("banned", []):
            return message.reply("You are banned")

        if "drop" not in data:
            return message.reply("No character has been dropped yet!")

        if len(message.command) < 2:
            return message.reply("Usage: /get [character_name]")

        name = " ".join(message.command[1:]).strip().lower()
        dropped = data["drop"]

        if dropped["name"].lower() != name:
            return message.reply("This character was not dropped!")

        # Add card to user
        if user_id not in data["users"]:
            data["users"][user_id] = []
        data["users"][user_id].append(dropped["id"])

        rarity = dropped["rarity"]
        emoji = RARITY_EMOJIS.get(rarity, "")

        message.reply(f"You got it!\nname: {dropped['name']}\nAnime: {dropped['anime']}\nRarity: {rarity} {emoji}")
        data.pop("drop")
        save_cards(data)

    @app.on_message(filters.command("harem") & filters.group)
    def show_harem(client: Client, message: Message):
        data = load_cards()
        user_id = str(message.from_user.id)
        if user_id in data.get("banned", []):
            return message.reply("You are banned")

        user_cards = data["users"].get(user_id, [])
        if not user_cards:
            return message.reply("You don't have any characters in your harem yet!")

        card_map = {str(card["id"]): card for card in data["cards"]}
        harem_list = []
        for cid in user_cards:
            card = card_map.get(str(cid))
            if card:
                emoji = RARITY_EMOJIS.get(card["rarity"], "")
                harem_list.append(f"{card['id']}: {card['name']} ({card['anime']}) {emoji}")

        harem_text = "\n".join(harem_list)
        message.reply(f"Your Harem:\n{harem_text}")

    @app.on_message(filters.command("search") & filters.group)
    def search_card(client: Client, message: Message):
        data = load_cards()
        if len(message.command) < 2:
            return message.reply("Usage: /search [name or id]")

        query = " ".join(message.command[1:]).lower()
        results = []
        for card in data["cards"]:
            if query in card["name"].lower() or query == str(card["id"]):
                emoji = RARITY_EMOJIS.get(card["rarity"], "")
                button = InlineKeyboardMarkup([[
                    InlineKeyboardButton("Who Have?", callback_data=f"whohave_{card['id']}")
                ]])
                message.reply(f"{card['id']}: {card['name']}\n{card['anime']}\nRarity: {card['rarity']} {emoji}", reply_markup=button)
                return

        message.reply("Card not found.")

    @app.on_callback_query(filters.regex(r"whohave_(\d+)"))
    def who_have(client, callback_query):
        data = load_cards()
        card_id = callback_query.data.split("_")[1]
        owners = []
        for user_id, cards in data["users"].items():
            count = cards.count(int(card_id))
            if count:
                owners.append((user_id, count))

        if not owners:
            return callback_query.message.edit_text("No one owns this card.")

        owners_text = "\n".join([f"ID: {uid} - Count: {cnt}" for uid, cnt in owners[:15]])
        callback_query.message.edit_text(f"Owners of card {card_id}:\n{owners_text}")


# utils.py
def find_card_by_id_or_name(session, query):
    if query.isdigit():
        return session.query(Card).filter(Card.id == int(query)).first()
    return session.query(Card).filter(Card.name.ilike(f"%{query}%")).first()

def get_users_with_card(session, card_id):
    result = (
        session.query(User, UserCard)
        .join(UserCard)
        .filter(UserCard.card_id == card_id)
        .order_by(UserCard.count.desc())
        .limit(15)
        .all()
    )
    return result

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.callback_data import CallbackData
from utils import find_card_by_id_or_name, get_users_with_card

whohave_cb = CallbackData("whohave", "card_id")

@dp.message_handler(commands=["search"])
async def cmd_search(message: types.Message):
    args = message.get_args()
    if not args:
        return await message.reply("Please provide a card name or ID.\nUsage: /search [name or ID]")

    session = Session()
    card = find_card_by_id_or_name(session, args.strip())
    if not card:
        return await message.reply("Card not found.")

    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("ğŸ‘¥ Who Have?", callback_data=whohave_cb.new(card_id=card.id))
    )

    caption = f"ğŸ†” ID: {card.id}\nğŸ‘¤ Name: {card.name}\nğŸ“º Anime: {card.anime}\nğŸŒŸ Rarity: {rarity_emoji.get(card.rarity, '')}{card.rarity}"
    if card.image_file_id:
        await message.reply_photo(photo=card.image_file_id, caption=caption, reply_markup=keyboard)
    elif card.video_file_id:
        await message.reply_video(video=card.video_file_id, caption=caption, reply_markup=keyboard)
    else:
        await message.reply("Card media not found.")
    session.close()

@dp.callback_query_handler(whohave_cb.filter())
async def who_have_callback(query: types.CallbackQuery, callback_data: dict):
    card_id = int(callback_data["card_id"])
    session = Session()
    users = get_users_with_card(session, card_id)

    if not users:
        return await query.answer("Nobody owns this card yet.")

    lines = []
    for i, (user, uc) in enumerate(users, 1):
        lines.append(f"{i}. {user.display_name or user.username or user.telegram_id} (x{uc.count})\nID: {user.telegram_id}")

    text = "\n".join(lines)
    await query.message.reply(f"ğŸ‘¥ Users who own this card:\n\n{text}")
    session.close()

# utils.py
def user_has_card(session, user_id, card_id):
    return session.query(UserCard).filter_by(user_id=user_id, card_id=card_id).first()

def transfer_card(session, from_user_id, to_user_id, card_id):
    sender_card = session.query(UserCard).filter_by(user_id=from_user_id, card_id=card_id).first()
    if sender_card:
        sender_card.count -= 1
        if sender_card.count <= 0:
            session.delete(sender_card)
        receiver_card = session.query(UserCard).filter_by(user_id=to_user_id, card_id=card_id).first()
        if receiver_card:
            receiver_card.count += 1
        else:
            session.add(UserCard(user_id=to_user_id, card_id=card_id, count=1))
        session.commit()
        return True
    return False

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.callback_data import CallbackData
from utils import user_has_card, transfer_card

gift_cb = CallbackData("gift", "from_id", "to_id", "card_id")

@dp.message_handler(commands=["gift"])
async def cmd_gift(message: types.Message):
    args = message.get_args().strip()
    if not message.reply_to_message:
        return await message.reply("You must reply to a user's message to gift a card.")

    to_id = message.reply_to_message.from_user.id
    from_id = message.from_user.id

    if not args.isdigit():
        return await message.reply("Please provide a valid card ID.\nUsage: /gift [card_id]")

    card_id = int(args)
    session = Session()
    if not user_has_card(session, from_id, card_id):
        session.close()
        return await message.reply("You don't have this card.")

    confirm_btn = InlineKeyboardMarkup().add(
        InlineKeyboardButton("âœ… Confirm Gift", callback_data=gift_cb.new(from_id=from_id, to_id=to_id, card_id=card_id))
    )
    await message.reply(f"Are you sure you want to gift card ID {card_id} to this user?", reply_markup=confirm_btn)
    session.close()

@dp.callback_query_handler(gift_cb.filter())
async def confirm_gift_callback(query: types.CallbackQuery, callback_data: dict):
    from_id = int(callback_data["from_id"])
    to_id = int(callback_data["to_id"])
    card_id = int(callback_data["card_id"])

    if query.from_user.id != from_id:
        return await query.answer("Only the sender can confirm this gift.", show_alert=True)

    session = Session()
    success = transfer_card(session, from_id, to_id, card_id)
    session.close()

    if success:
        await query.message.edit_text("ğŸ Card gifted successfully.")
    else:
        await query.message.edit_text("âš ï¸ Failed to transfer card. Maybe you no longer have it.")

def confirm_trade(session, user1_id, user2_id, card1_id, card2_id):
    uc1 = session.query(UserCard).filter_by(user_id=user1_id, card_id=card1_id).first()
    uc2 = session.query(UserCard).filter_by(user_id=user2_id, card_id=card2_id).first()
    if not uc1 or not uc2:
        return False

    # Ú©Ù… Ú©Ø±Ø¯Ù† Ø§Ø² Ø§ÙˆÙ„ÛŒ
    uc1.count -= 1
    if uc1.count <= 0:
        session.delete(uc1)
    
    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø¯ÙˆÙ…ÛŒ
    uc1r = session.query(UserCard).filter_by(user_id=user2_id, card_id=card1_id).first()
    if uc1r:
        uc1r.count += 1
    else:
        session.add(UserCard(user_id=user2_id, card_id=card1_id, count=1))

    # Ú©Ù… Ú©Ø±Ø¯Ù† Ø§Ø² Ø¯ÙˆÙ…ÛŒ
    uc2.count -= 1
    if uc2.count <= 0:
        session.delete(uc2)
    
    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø§ÙˆÙ„ÛŒ
    uc2r = session.query(UserCard).filter_by(user_id=user1_id, card_id=card2_id).first()
    if uc2r:
        uc2r.count += 1
    else:
        session.add(UserCard(user_id=user1_id, card_id=card2_id, count=1))

    session.commit()
    return True

from utils import confirm_trade
from aiogram.utils.callback_data import CallbackData

trade_cb = CallbackData("trade", "from_id", "to_id", "card1_id", "card2_id")

@dp.message_handler(commands=["trade"])
async def cmd_trade(message: types.Message):
    args = message.get_args().split()
    if not message.reply_to_message or len(args) != 2:
        return await message.reply("Usage:\n/reply to a user\n/trade [your_card_id] [their_card_id]")

    from_id = message.from_user.id
    to_id = message.reply_to_message.from_user.id

    if not all(arg.isdigit() for arg in args):
        return await message.reply("Card IDs must be numbers.")

    card1_id, card2_id = map(int, args)
    session = Session()

    has_from = user_has_card(session, from_id, card1_id)
    has_to = user_has_card(session, to_id, card2_id)

    if not has_from:
        session.close()
        return await message.reply("You don't own the card you're offering.")
    if not has_to:
        session.close()
        return await message.reply("The other user doesn't own the card you're asking for.")

    session.close()
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("âœ… Accept Trade", callback_data=trade_cb.new(
            from_id=from_id, to_id=to_id, card1_id=card1_id, card2_id=card2_id
        ))
    )
    await message.reply(
        f"{message.reply_to_message.from_user.first_name}, do you accept the trade?\n"
        f"You'll give card ID {card2_id} and get card ID {card1_id}.",
        reply_markup=keyboard
    )

@dp.callback_query_handler(trade_cb.filter())
async def accept_trade(query: types.CallbackQuery, callback_data: dict):
    from_id = int(callback_data["from_id"])
    to_id = int(callback_data["to_id"])
    card1_id = int(callback_data["card1_id"])
    card2_id = int(callback_data["card2_id"])

    if query.from_user.id != to_id:
        return await query.answer("Only the user being traded with can accept.", show_alert=True)

    session = Session()
    success = confirm_trade(session, from_id, to_id, card1_id, card2_id)
    session.close()

    if success:
        await query.message.edit_text("âœ… Trade completed successfully!")
    else:
        await query.message.edit_text("âš ï¸ Trade failed. One of the cards is missing.")

@dp.message_handler(commands=["show"])
async def cmd_show(message: types.Message):
    args = message.get_args().strip()
    if not args.isdigit():
        return await message.reply("Usage: /show [card_id]")

    card_id = int(args)
    session = Session()
    card = session.query(Card).filter_by(id=card_id).first()

    if not card:
        session.close()
        return await message.reply("âŒ Card not found.")

    # Ú†Ú© Ù…Ø§Ù„Ú©ÛŒØª
    has_card = user_has_card(session, message.from_user.id, card_id)

    caption = f"ğŸ†” ID: {card.id}\n" \
              f"ğŸ§¬ Name: {card.name}\n" \
              f"ğŸ“º Anime: {card.anime}\n" \
              f"ğŸ–ï¸ Rarity: {rarity_emojis.get(card.rarity, '')} {card.rarity}\n" \
              f"ğŸ‘¤ Owned by you: {'âœ… Yes' if has_card else 'âŒ No'}"

    if card.is_video:
        await message.reply_video(card.file_id, caption=caption)
    else:
        await message.reply_photo(card.file_id, caption=caption)

    session.close()

# rarity_emojis = {rarity: emoji}
rarity_emojis = {
    "common": "âšªï¸", "uncommon": "ğŸŸ£", "rare": "ğŸŸ ",
    "legendary": "ğŸŸ¡", "history": "ğŸ”±", "divine": "ğŸŒŸ",
    "exotic": "ğŸ’", "edit": "âœ¨"
}

@dp.message_handler(commands=["top_harem"])
async def cmd_top_harem(message: types.Message):
    session = Session()

    # Ø´Ù…Ø§Ø±Ø´ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ø§Ø±Ø¨Ø±
    results = session.query(
        UserCard.user_id,
        func.count(UserCard.card_id).label("unique_cards"),
        func.sum(UserCard.count).label("total_cards")
    ).group_by(UserCard.user_id).order_by(
        func.count(UserCard.card_id).desc(), func.sum(UserCard.count).desc()
    ).limit(10).all()

    if not results:
        session.close()
        return await message.reply("Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù‡Ù†ÙˆØ² Ú©Ø§Ø±ØªÛŒ Ù†Ø¯Ø§Ø±Ù‡.")

    text = "ğŸ† Top 10 Harems:\n\n"
    for idx, row in enumerate(results, 1):
        user_id = row.user_id
        try:
            user = await bot.get_chat(user_id)
            name = user.full_name
        except:
            name = f"User {user_id}"

        text += f"{idx}. {name} â€” {row.unique_cards} cards ({row.total_cards} total)\n"

    session.close()
    await message.reply(text)

@dp.message_handler(commands=["help"])
async def cmd_help(message: types.Message):
    help_text = """
ğŸ“– <b>User Commands</b>:

ğŸ´ /get [name]
Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±ØªÛŒ Ú©Ù‡ Ø¯Ø± Ú†Øª Ø§Ø³Ù¾Ø§ÙˆÙ† Ø´Ø¯Ù‡

ğŸ‘˜ /harem
Ø¯ÛŒØ¯Ù† Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§

ğŸ” /search [name or id]
Ø¬Ø³ØªØ¬ÙˆÛŒ Ú©Ø§Ø±Øª Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³

ğŸ /gift [card_id] (Ø±ÛŒÙ¾Ù„Ø§ÛŒ)
Ù‡Ø¯ÛŒÙ‡ Ø¯Ø§Ø¯Ù† Ú©Ø§Ø±Øª Ø¨Ù‡ Ø´Ø®ØµÛŒ Ø¯ÛŒÚ¯Ø±

ğŸ”„ /trade [your_card_id] [their_card_id] (Ø±ÛŒÙ¾Ù„Ø§ÛŒ)
Ù…Ø¨Ø§Ø¯Ù„Ù‡ Ú©Ø§Ø±Øª Ø¨Ø§ Ø¯ÛŒÚ¯Ø±Ø§Ù† Ø¨Ø§ ØªØ£ÛŒÛŒØ¯ Ø¯Ùˆ Ø·Ø±Ù

ğŸ–¼ /show [id]
Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Øª Ø®Ø§Øµ Ø¨Ø§ Ø¬Ø²Ø¦ÛŒØ§Øª

ğŸ† /top_harem
Ù†Ù…Ø§ÛŒØ´ Û±Û° Ù†ÙØ± Ø§ÙˆÙ„ Ø¨Ø§ Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ú©Ø§Ø±Øª

â“ /help
Ù†Ù…Ø§ÛŒØ´ Ø§ÛŒÙ† Ù„ÛŒØ³Øª
"""
    await message.reply(help_text, parse_mode="HTML")

@dp.message_handler(commands=["help_admins"])
async def cmd_help_admins(message: types.Message):
    session = Session()
    user_id = message.from_user.id
    user = session.query(User).filter_by(user_id=user_id).first()
    session.close()

    if not user or (not user.is_admin and not user.is_owner):
        return await message.reply("â›”ï¸ ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§ Ùˆ Ù…Ø§Ù„Ú© Ù…ÛŒâ€ŒØªÙˆÙ†Ù† Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ùˆ Ø§Ø¬Ø±Ø§ Ú©Ù†Ù†.")

    help_text = """
ğŸ›  <b>Admin Commands</b>:

â• /add_card
Ø§ÙØ²ÙˆØ¯Ù† Ú©Ø§Ø±Øª Ø¬Ø¯ÛŒØ¯ Ù…Ø±Ø­Ù„Ù‡â€ŒØ¨Ù‡â€ŒÙ…Ø±Ø­Ù„Ù‡ (Ù†Ø§Ù…ØŒ Ø§Ù†ÛŒÙ…Ù‡ØŒ Ø±ÛŒØ±ØªÛŒØŒ Ø¹Ú©Ø³/ÙˆÛŒØ¯ÛŒÙˆ)

ğŸ—‘ /del_card [id]
Ø­Ø°Ù Ú©Ø§Ù…Ù„ Ú©Ø§Ø±Øª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ùˆ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†

ğŸ†” /edit_id [id]
ØªØºÛŒÛŒØ± Ø¢ÛŒâ€ŒØ¯ÛŒ Ú©Ø§Ø±Øª (Ø§Ú¯Ø± ØªÚ©Ø±Ø§Ø±ÛŒ Ù†Ø¨Ø§Ø´Ø¯)

ğŸ /ggrant [id] (Ø±ÛŒÙ¾Ù„Ø§ÛŒ)
Ø¯Ø§Ø¯Ù† Ú©Ø§Ø±Øª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ù…ÙˆØ±Ø¯Ù†Ø¸Ø±

ğŸ“ˆ /increase [num] (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
Ø¯Ø§Ø¯Ù† ØªØµØ§Ø¯ÙÛŒ n Ú©Ø§Ø±Øª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±

ğŸ“‰ /reduce [num] (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
Ø­Ø°Ù ØªØµØ§Ø¯ÙÛŒ n Ú©Ø§Ø±Øª Ø§Ø² Ú©Ø§Ø±Ø¨Ø±

ğŸš« /bang (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
Ø¨ÛŒâ€ŒØ§Ø«Ø± Ú©Ø±Ø¯Ù† Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ Ùˆ Ø¯Ø³ØªÙˆØ±Ø§Øª Ú©Ø§Ø±Ø¨Ø± (Ù…ÙˆÙ‚ØªÛŒ)

âœ… /unbang (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
Ø®Ø§Ø±Ø¬ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø± Ø§Ø² Ø­Ø§Ù„Øª Ø¨Ù†Ú¯

ğŸ“ƒ /list_bang
Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ù†Ú¯ Ø´Ø¯Ù‡

ğŸ“„ /list_cards
Ù„ÛŒØ³Øª Ú©Ø§Ù…Ù„ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ (idØŒ Ù†Ø§Ù…ØŒ Ø§Ù†ÛŒÙ…Ù‡)

ğŸ“Š /card_stats [id]
Ù†Ù…Ø§ÛŒØ´ Ø¢Ù…Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯Ú¯Ø§Ù† Ú©Ø§Ø±Øª Ù…Ø´Ø®Øµ

ğŸ“– /help_admins
Ù†Ù…Ø§ÛŒØ´ Ù‡Ù…ÛŒÙ† Ù„ÛŒØ³Øª

ğŸ‘‘ Ø¯Ø³ØªÙˆØ±Ø§Øª Ù…Ø§Ù„Ú© Ù‡Ù… Ø§Ø² Ø·Ø±ÛŒÙ‚ /help_owner ÛŒØ§ Ù„ÛŒØ³Øª Ø¨Ø§Ù„Ø§ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒØ´Ù‡.
"""
    await message.reply(help_text, parse_mode="HTML")

@dp.message_handler(commands=["help_owner"])
async def cmd_help_owner(message: types.Message):
    session = Session()
    user_id = message.from_user.id
    user = session.query(User).filter_by(user_id=user_id).first()
    session.close()

    if not user or not user.is_owner:
        return await message.reply("â›”ï¸ ÙÙ‚Ø· Ù…Ø§Ù„Ú© Ø±Ø¨Ø§Øª Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ùˆ Ø§Ø¬Ø±Ø§ Ú©Ù†Ù‡.")

    help_text = """
ğŸ‘‘ <b>Owner Commands</b>:

ğŸ‘® /add_admin (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
ØªØ¨Ø¯ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ø§Ø¯Ù…ÛŒÙ†

ğŸ‘‹ /remove_admin (Ø±ÛŒÙ¾Ù„Ø§ÛŒ ÛŒØ§ user_id)
Ø­Ø°Ù Ø§Ø¯Ù…ÛŒÙ† Ø§Ø² Ù„ÛŒØ³Øª

ğŸ“ƒ /list_admin
Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª ØªÙ…Ø§Ù… Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§

ğŸ—‘ /delete_card [user_id] [card_id] (ÛŒØ§ Ø±ÛŒÙ¾Ù„Ø§ÛŒ)
Ø­Ø°Ù ÛŒÚ© Ú©Ø§Ø±Øª Ø®Ø§Øµ Ø§Ø² Ø­Ø§Ø±Ù… ÛŒÚ© Ú©Ø§Ø±Ø¨Ø±

ğŸ” /transfer [from_user_id] [to_user_id]
Ø§Ù†ØªÙ‚Ø§Ù„ Ú©Ø§Ù…Ù„ Ø­Ø§Ø±Ù… ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ø¯ÛŒÚ¯Ø±ÛŒ

ğŸ§  /help_owner
Ù†Ù…Ø§ÛŒØ´ Ù‡Ù…ÛŒÙ† Ù„ÛŒØ³Øª
"""
    await message.reply(help_text, parse_mode="HTML")

from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram import types
from loader import dp
from database import Session, Card, User
from utils.misc.rarity import valid_rarities

class AddCard(StatesGroup):
    waiting_for_name = State()
    waiting_for_anime = State()
    waiting_for_rarity = State()
    waiting_for_media = State()

@dp.message_handler(commands=['add_card'])
async def start_add_card(message: types.Message):
    session = Session()
    user = session.query(User).filter_by(user_id=message.from_user.id).first()
    session.close()

    if not user or not (user.is_admin or user.is_owner):
        return await message.reply("â›”ï¸ ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§ ÛŒØ§ Ù…Ø§Ù„Ú© Ù…ÛŒâ€ŒØªÙˆÙ†Ù† Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ùˆ Ø¨Ø²Ù†Ù†.")
    
    await message.reply("ğŸ‘¤ Ù„Ø·ÙØ§Ù‹ Ø§Ø³Ù… Ú©Ø§Ø±Ø§Ú©ØªØ± Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†:")
    await AddCard.waiting_for_name.set()

@dp.message_handler(state=AddCard.waiting_for_name)
async def get_card_name(message: types.Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.reply("ğŸ¬ Ù„Ø·ÙØ§Ù‹ Ø§Ø³Ù… Ø§Ù†ÛŒÙ…Ù‡ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†:")
    await AddCard.waiting_for_anime.set()

@dp.message_handler(state=AddCard.waiting_for_anime)
async def get_anime_name(message: types.Message, state: FSMContext):
    await state.update_data(anime=message.text)
    await message.reply("ğŸ“Š Ù„Ø·ÙØ§Ù‹ Ø±Ø±ÛŒØªÛŒ Ú©Ø§Ø±Øª Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù† (Ù…Ø«Ù„Ø§Ù‹: commonØŒ rareØŒ exotic):")
    await AddCard.waiting_for_rarity.set()

@dp.message_handler(state=AddCard.waiting_for_rarity)
async def get_rarity(message: types.Message, state: FSMContext):
    rarity = message.text.lower()
    if rarity not in valid_rarities:
        return await message.reply("â›”ï¸ Ø±Ø±ÛŒØªÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±. Ù„Ø·ÙØ§Ù‹ ÛŒÚ©ÛŒ Ø§Ø² Ø§ÛŒÙ†Ù‡Ø§ Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†:\n" + ", ".join(valid_rarities))
    await state.update_data(rarity=rarity)
    await message.reply("ğŸ“· Ù„Ø·ÙØ§Ù‹ Ø¹Ú©Ø³ ÛŒØ§ ÙˆÛŒØ¯ÛŒÙˆ Ú©Ø§Ø±Øª Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†:")
    await AddCard.waiting_for_media.set()

@dp.message_handler(state=AddCard.waiting_for_media, content_types=['photo', 'video'])
async def get_media(message: types.Message, state: FSMContext):
    data = await state.get_data()

    session = Session()
    last_card = session.query(Card).order_by(Card.id.desc()).first()
    card_id = 1 if not last_card else last_card.id + 1

    if message.photo:
        file_id = message.photo[-1].file_id
        media_type = 'photo'
    else:
        file_id = message.video.file_id
        media_type = 'video'

    new_card = Card(
        id=card_id,
        name=data['name'],
        anime=data['anime'],
        rarity=data['rarity'],
        media_type=media_type,
        file_id=file_id
    )

    session.add(new_card)
    session.commit()
    session.close()

    await message.reply(f"âœ… Ú©Ø§Ø±Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!\nID: <code>{card_id}</code>", parse_mode="HTML")
    await state.finish()

# models.py
class Card(Base):
    __tablename__ = "cards"

    id = Column(Integer, primary_key=True)
    name = Column(String)
    anime = Column(String)
    rarity = Column(String)
    media_type = Column(String)  # 'photo' ÛŒØ§ 'video'
    file_id = Column(String)

valid_rarities = [
    "common", "uncommon", "rare", "legendary",
    "history", "divine", "exotic", "edit"
]




    
